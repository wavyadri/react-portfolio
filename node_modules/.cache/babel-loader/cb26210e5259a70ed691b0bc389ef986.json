{"ast":null,"code":"import _slicedToArray from\"C:/Users/adria/Documents/coding projects/adriana-portfolio-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useState,useEffect,useRef}from'react';import{jsx as _jsx}from\"react/jsx-runtime\";var Typewriter=function Typewriter(){var text=['Web Developer','Problem Solver','Team Player'];var i=0;var j=0;var _useState=useState([]),_useState2=_slicedToArray(_useState,2),currentWord=_useState2[0],setCurrentWord=_useState2[1];var charIndex=useRef(0);var textIndex=useRef(0);var _useState3=useState(false),_useState4=_slicedToArray(_useState3,2),isDeleting=_useState4[0],setIsDeleting=_useState4[1];var _useState5=useState(false),_useState6=_slicedToArray(_useState5,2),isEnd=_useState6[0],setIsEnd=_useState6[1];// const loop = () => {\n//     setIsDeleting(false);\n// //     if (i < text.length) {\n// //         // if we're typing and we haven't completed the word\n// //         if (!isDeleting && j <= text[textIndex].length) {\n// //             setCurrentWord((value) => value + text[textIndex].charAt(charIndex.current))\n// //             j++;\n// //         }\n//         // if(isDeleting && charIndex <= text[textIndex].length) {\n//         //     word.pop(text[textIndex][charIndex]);\n//         //     charIndex--;\n//         //     setCurrentWord(word.join(''));\n//         // }\n//         // if (charIndex == text[textIndex].length) {\n//         //     setIsDeleting(true);\n//         // }\n//         // if (isDeleting && charIndex === 0) {\n//         //     word = [];\n//         //     setIsDeleting(false);\n//         //     textIndex++;\n//         //     if(textIndex === word.length) {\n//         //         textIndex = 0;\n//         //     }\n//         // }\n//     }\n// }\nvar loopLoop=function loopLoop(){setIsDeleting(false);if(textIndex.current<text.length){// if we're typing and we haven't completed the word\nif(!isDeleting&&charIndex.current<text[textIndex.current].length){setCurrentWord(function(value){return value+text[textIndex.current].charAt(charIndex.current);});charIndex.current++;}// if(isDeleting && ) {\n//     setCurrentWord((value) => value - text[textIndex.current].charAt(charIndex.current))\n//     charIndex.current--;\n// }\nif(isDeleting&&charIndex.current<=text[textIndex.current].length){setCurrentWord(function(value){return value-text[textIndex.current].charAt(charIndex.current);});charIndex.current--;}if(charIndex.current===text[textIndex.current].length){setCurrentWord(text[textIndex.current]);console.log(charIndex.current);console.log(text[textIndex.current].length);setIsDeleting(true);}// if(isDeleting && charIndex.current <= text[i].length) {\n//     setCurrentWord((value) => value - text[i].charAt(charIndex.current))\n//     charIndex.current -= 1;\n// }\n}};useEffect(function(){setTimeout(function(){loopLoop();},300);return function(){clearTimeout();};},[currentWord,setIsDeleting]);return/*#__PURE__*/_jsx(\"div\",{children:/*#__PURE__*/_jsx(\"h3\",{children:currentWord})});};export default Typewriter;","map":{"version":3,"sources":["C:/Users/adria/Documents/coding projects/adriana-portfolio-react/src/components/Typewriter.js"],"names":["React","useState","useEffect","useRef","Typewriter","text","i","j","currentWord","setCurrentWord","charIndex","textIndex","isDeleting","setIsDeleting","isEnd","setIsEnd","loopLoop","current","length","value","charAt","console","log","setTimeout","clearTimeout"],"mappings":"uLAAA,MAAOA,CAAAA,KAAP,EAAeC,QAAf,CAAyBC,SAAzB,CAAoCC,MAApC,KAAiD,OAAjD,C,2CAEA,GAAMC,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,EAAM,CACrB,GAAIC,CAAAA,IAAI,CAAG,CAAC,eAAD,CAAkB,gBAAlB,CAAoC,aAApC,CAAX,CAEA,GAAIC,CAAAA,CAAC,CAAG,CAAR,CACA,GAAIC,CAAAA,CAAC,CAAG,CAAR,CAEA,cAAsCN,QAAQ,CAAC,EAAD,CAA9C,wCAAOO,WAAP,eAAoBC,cAApB,eACA,GAAMC,CAAAA,SAAS,CAAGP,MAAM,CAAC,CAAD,CAAxB,CACA,GAAMQ,CAAAA,SAAS,CAAGR,MAAM,CAAC,CAAD,CAAxB,CACA,eAAoCF,QAAQ,CAAC,KAAD,CAA5C,yCAAOW,UAAP,eAAmBC,aAAnB,eACA,eAA0BZ,QAAQ,CAAC,KAAD,CAAlC,yCAAOa,KAAP,eAAcC,QAAd,eAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA,GAAMC,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,EAAM,CACnBH,aAAa,CAAC,KAAD,CAAb,CAEA,GAAIF,SAAS,CAACM,OAAV,CAAoBZ,IAAI,CAACa,MAA7B,CAAqC,CACjC;AACA,GAAI,CAACN,UAAD,EAAeF,SAAS,CAACO,OAAV,CAAoBZ,IAAI,CAACM,SAAS,CAACM,OAAX,CAAJ,CAAwBC,MAA/D,CAAuE,CACnET,cAAc,CAAC,SAACU,KAAD,QAAWA,CAAAA,KAAK,CAAGd,IAAI,CAACM,SAAS,CAACM,OAAX,CAAJ,CAAwBG,MAAxB,CAA+BV,SAAS,CAACO,OAAzC,CAAnB,EAAD,CAAd,CACAP,SAAS,CAACO,OAAV,GACH,CAED;AACA;AACA;AACA;AACA,GAAGL,UAAU,EAAIF,SAAS,CAACO,OAAV,EAAqBZ,IAAI,CAACM,SAAS,CAACM,OAAX,CAAJ,CAAwBC,MAA9D,CAAsE,CAClET,cAAc,CAAC,SAACU,KAAD,QAAWA,CAAAA,KAAK,CAAGd,IAAI,CAACM,SAAS,CAACM,OAAX,CAAJ,CAAwBG,MAAxB,CAA+BV,SAAS,CAACO,OAAzC,CAAnB,EAAD,CAAd,CACAP,SAAS,CAACO,OAAV,GACH,CAED,GAAIP,SAAS,CAACO,OAAV,GAAsBZ,IAAI,CAACM,SAAS,CAACM,OAAX,CAAJ,CAAwBC,MAAlD,CAA0D,CACtDT,cAAc,CAACJ,IAAI,CAACM,SAAS,CAACM,OAAX,CAAL,CAAd,CACAI,OAAO,CAACC,GAAR,CAAYZ,SAAS,CAACO,OAAtB,EACAI,OAAO,CAACC,GAAR,CAAYjB,IAAI,CAACM,SAAS,CAACM,OAAX,CAAJ,CAAwBC,MAApC,EACAL,aAAa,CAAC,IAAD,CAAb,CACH,CAGD;AACA;AACA;AACA;AACH,CACJ,CAhCD,CAoCAX,SAAS,CAAC,UAAM,CACZqB,UAAU,CAAC,UAAM,CACbP,QAAQ,GAAG,CADL,CACO,GADP,CAAV,CAEA,MAAQ,WAAM,CACVQ,YAAY,GACf,CAFD,CAGH,CANQ,CAMN,CAAChB,WAAD,CAAcK,aAAd,CANM,CAAT,CASA,mBACI,kCACI,oBAAKL,WAAL,EADJ,EADJ,CAKH,CA9FD,CAgGA,cAAeJ,CAAAA,UAAf","sourcesContent":["import React, {useState, useEffect, useRef} from 'react'\r\n\r\nconst Typewriter = () => {\r\n    let text = ['Web Developer', 'Problem Solver', 'Team Player'];\r\n\r\n    let i = 0;\r\n    let j = 0;\r\n\r\n    const [currentWord, setCurrentWord] = useState([]);\r\n    const charIndex = useRef(0);\r\n    const textIndex = useRef(0);\r\n    const [isDeleting, setIsDeleting] = useState(false);\r\n    const [isEnd, setIsEnd] = useState(false);\r\n\r\n    // const loop = () => {\r\n    //     setIsDeleting(false);\r\n\r\n    // //     if (i < text.length) {\r\n    // //         // if we're typing and we haven't completed the word\r\n    // //         if (!isDeleting && j <= text[textIndex].length) {\r\n    // //             setCurrentWord((value) => value + text[textIndex].charAt(charIndex.current))\r\n    // //             j++;\r\n    // //         }\r\n\r\n    //         // if(isDeleting && charIndex <= text[textIndex].length) {\r\n    //         //     word.pop(text[textIndex][charIndex]);\r\n    //         //     charIndex--;\r\n    //         //     setCurrentWord(word.join(''));\r\n    //         // }\r\n\r\n    //         // if (charIndex == text[textIndex].length) {\r\n    //         //     setIsDeleting(true);\r\n    //         // }\r\n\r\n    //         // if (isDeleting && charIndex === 0) {\r\n    //         //     word = [];\r\n    //         //     setIsDeleting(false);\r\n    //         //     textIndex++;\r\n    //         //     if(textIndex === word.length) {\r\n    //         //         textIndex = 0;\r\n    //         //     }\r\n    //         // }\r\n    //     }\r\n       \r\n    // }\r\n\r\n    const loopLoop = () => {\r\n        setIsDeleting(false);\r\n        \r\n        if (textIndex.current < text.length) {\r\n            // if we're typing and we haven't completed the word\r\n            if (!isDeleting && charIndex.current < text[textIndex.current].length) {\r\n                setCurrentWord((value) => value + text[textIndex.current].charAt(charIndex.current))\r\n                charIndex.current++;\r\n            }\r\n\r\n            // if(isDeleting && ) {\r\n            //     setCurrentWord((value) => value - text[textIndex.current].charAt(charIndex.current))\r\n            //     charIndex.current--;\r\n            // }\r\n            if(isDeleting && charIndex.current <= text[textIndex.current].length) {\r\n                setCurrentWord((value) => value - text[textIndex.current].charAt(charIndex.current))\r\n                charIndex.current--;\r\n            }\r\n\r\n            if (charIndex.current === text[textIndex.current].length) {\r\n                setCurrentWord(text[textIndex.current])\r\n                console.log(charIndex.current);\r\n                console.log(text[textIndex.current].length);\r\n                setIsDeleting(true)\r\n            }\r\n\r\n\r\n            // if(isDeleting && charIndex.current <= text[i].length) {\r\n            //     setCurrentWord((value) => value - text[i].charAt(charIndex.current))\r\n            //     charIndex.current -= 1;\r\n            // }\r\n        }\r\n    }\r\n\r\n   \r\n\r\n    useEffect(() => {\r\n        setTimeout(() => {\r\n            loopLoop()}, 300)\r\n        return (() => {\r\n            clearTimeout();\r\n        })\r\n    }, [currentWord, setIsDeleting])\r\n\r\n\r\n    return (\r\n        <div>\r\n            <h3>{currentWord}</h3>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Typewriter\r\n"]},"metadata":{},"sourceType":"module"}